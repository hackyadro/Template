<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>Система локализации платы</title>
    <style>
      body {
        margin: 0;
        font-family: Segoe UI, sans-serif;
        background: #f4f6f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        transition: background 0.3s, color 0.3s;
      }

      body.dark {
        background: #2c3e50;
        color: #ecf0f1;
      }

      .map {
        margin-top: 20px;
        background: #fff;
        border: 2px solid #ddd;
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        padding: 16px;
      }

      .map.dark {
        background: #34495e;
        border-color: #555;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .map__controls {
        text-align: center;
        margin-bottom: 12px;
      }

      .map__button {
        margin: 4px;
        padding: 8px 14px;
        border: 0;
        border-radius: 6px;
        color: #fff;
        font-size: 14px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: transform 0.1s, box-shadow 0.2s;
      }

      .map__button:hover {
        transform: scale(1.05);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
      }

      .map__button:active {
        transform: scale(0.95);
      }

      .map__button_start {
        background: #27ae60;
      }

      .map__button_finish {
        background: #7f8c8d;
      }

      .map__button_export {
        background: #9b59b6;
      }

      .map__button_settings {
        background: #f39c12;
      }

      .map__container {
        display: flex;
        justify-content: center;
        align-items: center;
      }

      canvas {
        background: #fff;
        border: 1px solid #ccc;
      }

      /* Modal */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
      }

      .modal.show {
        display: flex;
      }

      .modal-content {
        background: #fff;
        padding: 25px;
        border-radius: 12px;
        width: 400px;
        position: relative;
        transform: scale(0.9);
        opacity: 0;
        transition: transform 0.3s ease, opacity 0.3s ease;
      }

      .modal.show .modal-content {
        transform: scale(1);
        opacity: 1;
      }

      .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-weight: bold;
        font-size: 20px;
        transition: transform 0.2s;
      }

      .modal-close:hover {
        transform: rotate(90deg);
        color: #e74c3c;
      }

      .modal-content label {
        display: block;
        margin: 10px 0 4px;
      }

      .modal-content select,
      .modal-content input[type="file"] {
        width: 100%;
        padding: 6px;
        margin-bottom: 10px;
      }

      .modal-content button {
        padding: 8px;
        width: 100%;
        border-radius: 6px;
        border: none;
        background: #2980b9;
        color: #fff;
        cursor: pointer;
        transition: transform 0.1s, box-shadow 0.2s;
      }

      .modal-content button:hover {
        transform: scale(1.05);
        box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
      }

      .modal-content button:active {
        transform: scale(0.95);
      }

      /* Toasts */
      #toastContainer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 9999;
      }

      .toast {
        padding: 10px 16px;
        margin-top: 8px;
        border-radius: 6px;
        color: #fff;
        min-width: 150px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.3s;
      }
    </style>
  </head>

  <body>
    <div class="map">
      <div class="map__controls">
        <button class="map__button map__button_start" onclick="startRoute()">
          <svg width="16" height="16" viewBox="0 0 24 24">
            <path fill="#fff" d="M8 5v14l11-7z" /></svg
          >Начать маршрут
        </button>
        <button class="map__button map__button_finish" onclick="stopRoute()">
          <svg width="16" height="16" viewBox="0 0 24 24">
            <path
              fill="#fff"
              d="M6 19h12V5H6v14zm2-2v-2h8v2H8zm0-4v-2h8v2H8z"
            /></svg
          >Завершить маршрут
        </button>
        <button class="map__button map__button_export" onclick="exportRoute()">
          <svg width="16" height="16" viewBox="0 0 24 24">
            <path
              fill="#fff"
              d="M5 20h14v-2H5v2zm7-18L5.33 9h3.34v6h4.66V9h3.34L12 2z"
            /></svg
          >Выгрузить (txt)
        </button>
        <button
          class="map__button map__button_settings"
          onclick="openSettings()"
        >
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="currentColor"
            xmlns="http://www.w3.org/2000/svg"
            class="icon"
            aria-hidden="true"
          >
            <path
              d="M10.3227 1.62663C11.1514 1.62663 11.9182 2.066 12.3373 2.78092L13.1586 4.18131L13.2123 4.25065C13.2735 4.31105 13.3565 4.34658 13.4448 4.34733L15.06 4.36002L15.2143 4.36686C15.9825 4.4239 16.6774 4.85747 17.0649 5.53092L17.393 6.10221L17.4662 6.23795C17.7814 6.88041 17.7842 7.63306 17.4741 8.27799L17.4028 8.41373L16.6 9.83561C16.5426 9.93768 16.5425 10.0627 16.6 10.1647L17.4028 11.5856L17.4741 11.7223C17.7841 12.3673 17.7815 13.1199 17.4662 13.7624L17.393 13.8981L17.0649 14.4694C16.6774 15.1427 15.9824 15.5764 15.2143 15.6335L15.06 15.6393L13.4448 15.653C13.3565 15.6537 13.2736 15.6892 13.2123 15.7497L13.1586 15.818L12.3373 17.2194C11.9182 17.9342 11.1513 18.3737 10.3227 18.3737H9.6762C8.8995 18.3735 8.17705 17.9874 7.74456 17.3503L7.66253 17.2194L6.84124 15.818C6.79652 15.7418 6.72408 15.6876 6.64105 15.6647L6.55511 15.653L4.93987 15.6393C4.16288 15.633 3.44339 15.2413 3.01605 14.6003L2.93499 14.4694L2.60687 13.8981C2.19555 13.1831 2.1916 12.3039 2.5971 11.5856L3.39886 10.1647L3.43206 10.0846C3.44649 10.0293 3.44644 9.97102 3.43206 9.91569L3.39886 9.83561L2.5971 8.41373C2.19175 7.6955 2.19562 6.8171 2.60687 6.10221L2.93499 5.53092L3.01605 5.40006C3.44337 4.75894 4.1628 4.36636 4.93987 4.36002L6.55511 4.34733L6.64105 4.33561C6.72418 4.31275 6.79651 4.25762 6.84124 4.18131L7.66253 2.78092L7.74456 2.65006C8.17704 2.01277 8.89941 1.62678 9.6762 1.62663H10.3227ZM9.6762 2.9567C9.36439 2.95685 9.07299 3.10138 8.88421 3.34342L8.80999 3.45377L7.9887 4.85416C7.72933 5.29669 7.28288 5.59093 6.78265 5.6608L6.56585 5.67741L4.95062 5.6901C4.63868 5.69265 4.34845 5.84001 4.16155 6.08366L4.08733 6.19401L3.75921 6.7653C3.58227 7.073 3.5808 7.45131 3.7553 7.76041L4.55706 9.18131L4.65179 9.37663C4.81309 9.77605 4.81294 10.2232 4.65179 10.6227L4.55706 10.819L3.7553 12.2399C3.58083 12.549 3.5822 12.9273 3.75921 13.235L4.08733 13.8053L4.16155 13.9157C4.34844 14.1596 4.6385 14.3067 4.95062 14.3092L6.56585 14.3229L6.78265 14.3385C7.28292 14.4084 7.72931 14.7036 7.9887 15.1462L8.80999 16.5465L8.88421 16.6559C9.07298 16.8982 9.36422 17.0435 9.6762 17.0436H10.3227C10.6793 17.0436 11.0095 16.8542 11.1899 16.5465L12.0112 15.1462L12.1332 14.9655C12.4432 14.5668 12.9212 14.3271 13.434 14.3229L15.0492 14.3092L15.1811 14.2995C15.4854 14.2567 15.7569 14.076 15.9125 13.8053L16.2407 13.235L16.2983 13.1169C16.3983 12.8745 16.3999 12.6023 16.3022 12.359L16.2446 12.2399L15.4418 10.819C15.1551 10.311 15.1551 9.6893 15.4418 9.18131L16.2446 7.76041L16.3022 7.64127C16.4 7.39806 16.3982 7.12584 16.2983 6.88346L16.2407 6.7653L15.9125 6.19401C15.7568 5.92338 15.4855 5.74264 15.1811 5.69987L15.0492 5.6901L13.434 5.67741C12.9212 5.67322 12.4432 5.43341 12.1332 5.03483L12.0112 4.85416L11.1899 3.45377C11.0095 3.14604 10.6794 2.9567 10.3227 2.9567H9.6762ZM11.5854 9.99967C11.5852 9.12461 10.8755 8.41497 10.0004 8.41471C9.12516 8.41471 8.41466 9.12445 8.41448 9.99967C8.41448 10.875 9.12505 11.5846 10.0004 11.5846C10.8756 11.5844 11.5854 10.8749 11.5854 9.99967ZM12.9145 9.99967C12.9145 11.6094 11.6101 12.9145 10.0004 12.9147C8.39051 12.9147 7.08538 11.6096 7.08538 9.99967C7.08556 8.38991 8.39062 7.08463 10.0004 7.08463C11.61 7.08489 12.9143 8.39007 12.9145 9.99967Z"
            ></path>
          </svg>
          Настройки
        </button>
        <div
          id="errorBox"
          style="color: #e74c3c; margin-top: 8px; font-size: 14px"
        ></div>
      </div>
      <div class="map__container">
        <canvas id="mapCanvas" width="700" height="700"></canvas>
      </div>
    </div>

    <div class="modal" id="settingsModal">
      <div class="modal-content">
        <span class="modal-close" onclick="closeSettings()">×</span>
        <label for="themeSelect">Тема:</label>
        <select id="themeSelect">
          <option value="light">Светлая</option>
          <option value="dark">Тёмная</option>
          <option value="system">Системная</option>
        </select>
        <label for="beaconFile">Загрузить файл маяков:</label>
        <input type="file" id="beaconFile" accept=".txt" />
        <button onclick="applySettings()">Применить</button>
      </div>
    </div>

    <!-- Toast container -->
    <div id="toastContainer"></div>

    <script>
      const cvs = document.getElementById("mapCanvas");
      const ctx = cvs.getContext("2d");
      let beacons = {},
        board = { x: 0, y: 0 },
        route = [],
        timer = null;
      let scale = 20,
        offsetX = cvs.width / 2,
        offsetY = cvs.height / 2;

      // Modal
      function openSettings() {
        const m = document.getElementById("settingsModal");
        m.style.display = "flex";
        m.classList.add("show");
      }
      function closeSettings() {
        const m = document.getElementById("settingsModal");
        m.classList.remove("show");
        setTimeout(() => {
          m.style.display = "none";
        }, 300);
      }
      window.addEventListener("click", (e) => {
        if (e.target.id === "settingsModal") closeSettings();
      });

      // Toast
      function showToast(msg, type = "info", duration = 3000) {
        const container = document.getElementById("toastContainer");
        const t = document.createElement("div");
        t.className = "toast";
        t.style.background =
          type === "success"
            ? "#27ae60"
            : type === "error"
            ? "#e74c3c"
            : "#3498db";
        t.textContent = msg;
        t.onclick = () => t.remove();
        container.appendChild(t);
        setTimeout(() => (t.style.opacity = "1"), 10);
        setTimeout(() => t.remove(), duration);
      }

      async function loadBeaconsFromFile(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter((l) => l.trim());
            const out = {};
            for (let i = 1; i < lines.length; i++) {
              const parts = lines[i].split(";");
              if (parts.length >= 2) {
                const x = parseFloat(parts[0].replace(",", "."));
                const y = parseFloat(parts[1].replace(",", "."));
                const name = parts[2]?.trim() || `beacon_${i}`;
                if (!isNaN(x) && !isNaN(y)) out[i] = { x, y, name };
              }
            }
            resolve(out);
          };
          reader.onerror = reject;
          reader.readAsText(file);
        });
      }

      function applySettings() {
        const theme = document.getElementById("themeSelect").value;
        let themeChanged = false;

        if (theme === "light" && document.body.classList.contains("dark")) {
          document.body.classList.remove("dark");
          themeChanged = true;
        } else if (
          theme === "dark" &&
          !document.body.classList.contains("dark")
        ) {
          document.body.classList.add("dark");
          themeChanged = true;
        } else if (theme === "system") {
          const prefersDark = window.matchMedia(
            "(prefers-color-scheme: dark)"
          ).matches;
          if (prefersDark && !document.body.classList.contains("dark")) {
            document.body.classList.add("dark");
            themeChanged = true;
          } else if (!prefersDark && document.body.classList.contains("dark")) {
            document.body.classList.remove("dark");
            themeChanged = true;
          }
        }

        if (themeChanged) showToast("Тема успешно применена", "info");

        const fileInput = document.getElementById("beaconFile");
        if (fileInput.files.length) {
          const file = fileInput.files[0];
          loadBeaconsFromFile(file)
            .then((loaded) => {
              beacons = loaded;
              board = { x: 0, y: 0 };
              computeTransform();
              drawAll();
              showToast("Файл маяков успешно загружен", "success");
              fileInput.value = "";
            })
            .catch(() => showToast("Ошибка чтения файла маяков", "error"));
        }

        closeSettings();
      }

      function mapFromApi(raw) {
        let out = {};
        if (!raw) return out;
        if (Array.isArray(raw.beacons)) {
          raw.beacons.forEach((b) => {
            if (b && b.id != null && b.x != null && b.y != null)
              out[String(b.id)] = {
                x: +b.x,
                y: +b.y,
                name: b.name || "beacon_" + b.id,
              };
          });
          return out;
        }
        if (typeof raw === "object") {
          for (const k of Object.keys(raw)) {
            const v = raw[k];
            if (v && v.x != null && v.y != null)
              out[String(k)] = {
                x: +v.x,
                y: +v.y,
                name: v.name || "beacon_" + k,
              };
          }
        }
        return out;
      }

      function computeTransform() {
        const ids = Object.keys(beacons);
        if (!ids.length) {
          scale = 20;
          offsetX = cvs.width / 2;
          offsetY = cvs.height / 2;
          return;
        }

        const xs = ids.map((i) => beacons[i].x - board.x),
          ys = ids.map((i) => beacons[i].y - board.y);
        const minX = Math.min(...xs),
          maxX = Math.max(...xs),
          minY = Math.min(...ys),
          maxY = Math.max(...ys);

        const maxRange = Math.max(
          Math.abs(minX),
          Math.abs(maxX),
          Math.abs(minY),
          Math.abs(maxY),
          0.0001
        );
        const padding = 40;
        const half = Math.min(cvs.width, cvs.height) / 2 - padding;
        scale = half / maxRange;
        if (!isFinite(scale) || scale <= 0) scale = 20;

        offsetX = cvs.width / 2;
        offsetY = cvs.height / 2;
      }

      function toCanvas(p) {
        return {
          x: offsetX + (p.x - board.x) * scale,
          y: offsetY - (p.y - board.y) * scale,
        };
      }

      function drawAll() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        if (!Object.keys(beacons).length) {
          ctx.strokeStyle = "#34495e";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, offsetY);
          ctx.lineTo(cvs.width, offsetY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(offsetX, 0);
          ctx.lineTo(offsetX, cvs.height);
          ctx.stroke();
          ctx.fillStyle = "#34495e";
          ctx.fillText("Нет маяков", 10, 20);
          return;
        }

        const CELL_SIZE = 40;
        ctx.strokeStyle = "#ecf0f1";
        ctx.lineWidth = 1;
        const startX = offsetX % CELL_SIZE;
        const startY = offsetY % CELL_SIZE;

        for (let x = startX; x <= cvs.width; x += CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cvs.height);
          ctx.stroke();
        }
        for (let x = startX - CELL_SIZE; x >= 0; x -= CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, cvs.height);
          ctx.stroke();
        }
        for (let y = startY; y <= cvs.height; y += CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cvs.width, y);
          ctx.stroke();
        }
        for (let y = startY - CELL_SIZE; y >= 0; y -= CELL_SIZE) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(cvs.width, y);
          ctx.stroke();
        }

        ctx.strokeStyle = "#34495e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, offsetY);
        ctx.lineTo(cvs.width, offsetY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(offsetX, 0);
        ctx.lineTo(offsetX, cvs.height);
        ctx.stroke();
        ctx.fillStyle = "#34495e";
        ctx.fillText("X", cvs.width - 20, offsetY - 5);
        ctx.fillText("Y", offsetX + 10, 15);

        ctx.font = "bold 12px Segoe UI";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (const id of Object.keys(beacons)) {
          const b = beacons[id],
            c = toCanvas(b);
          ctx.beginPath();
          ctx.arc(c.x, c.y, 12, 0, 2 * Math.PI);
          ctx.fillStyle = "#f39c12";
          ctx.fill();
          ctx.strokeStyle = "#e67e22";
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.fillStyle = "#fff";
          ctx.fillText(id, c.x, c.y);
        }

        if (route.length > 1) {
          ctx.beginPath();
          const f = toCanvas(route[0]);
          ctx.moveTo(f.x, f.y);
          for (let i = 1; i < route.length; i++) {
            const p = toCanvas(route[i]);
            ctx.lineTo(p.x, p.y);
          }
          ctx.strokeStyle = "#2980b9";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        const cb = toCanvas(board);
        ctx.beginPath();
        ctx.arc(cb.x, cb.y, 10, 0, 2 * Math.PI);
        ctx.fillStyle = "#2980b9";
        ctx.fill();
        ctx.strokeStyle = "rgba(41,128,185,0.4)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cb.x, cb.y, 16, 0, 2 * Math.PI);
        ctx.stroke();
      }

      async function fetchBeacons() {
        try {
          const r = await fetch("/api/beacons");
          if (!r.ok) throw new Error("status " + r.status);
          const json = await r.json();
          beacons = mapFromApi(json);
          computeTransform();
          drawAll();
          return true;
        } catch (err) {
          console.error("beacons fetch error", err);
          return false;
        }
      }

      async function startRoute() {
        if (timer) return;
        document.getElementById("errorBox").textContent = "";

        try {
          const resp = await fetch("/api/check_board");
          if (!resp.ok) throw new Error("status " + resp.status);
          const ok = await resp.json();
          if (!ok || ok.res === false) {
            document.getElementById("errorBox").textContent =
              "Ошибка: плата не подключена.";
            return;
          }
        } catch (err) {
          console.error("startRoute error", err);
          document.getElementById("errorBox").textContent =
            "Ошибка соединения с сервером.";
          return;
        }

        try {
          const resp = await fetch("/api/start_way", { method: "POST" });
          if (!resp.ok) {
            showToast("Ошибка запуска маршрута", "error");
            return;
          }
        } catch (err) {
          console.error(err);
          return;
        }

        route = [];
        board = { x: 0, y: 0 };
        computeTransform();
        drawAll();

        timer = setInterval(async () => {
          try {
            const r = await fetch("/api/get_positions");
            const j = await r.json();
            if (j.positions && j.positions.length) {
              const newPos = j.positions
                .slice(route.length)
                .map((p) => ({ x: +p.x, y: +p.y }));
              route.push(...newPos);
              if (route.length) board = route[route.length - 1];
              computeTransform();
              drawAll();
            }
          } catch (e) {
            console.error("pos fetch error", e);
          }
        }, 2000);
      }

      async function stopRoute() {
        if (!timer) return;
        clearInterval(timer);
        timer = null;
        try {
          const resp = await fetch("/api/finish_way", { method: "POST" });
          if (!resp.ok) {
            showToast("Ошибка завершения маршрута", "error");
            return;
          }
          showToast("Маршрут завершён", "success");
        } catch (err) {
          console.error(err);
          showToast("Ошибка завершения маршрута", "error");
        }
      }

      function exportRoute() {
        if (!route.length) return showToast("Маршрут пуст", "info");
        const txt =
          "X;Y\n" +
          route
            .map(
              (p) =>
                `${p.x.toFixed(1).replace(".", ",")};${p.y
                  .toFixed(1)
                  .replace(".", ",")}`
            )
            .join("\n");
        const a = document.createElement("a");
        a.href = URL.createObjectURL(new Blob([txt], { type: "text/plain" }));
        a.download = "route.txt";
        a.click();
        showToast("Маршрут успешно выгружен", "success");
      }

      (async function init() {
        await fetchBeacons();
        setInterval(fetchBeacons, 5000);
      })();
    </script>
  </body>
</html>
