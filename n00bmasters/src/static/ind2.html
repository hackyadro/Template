<!-- ... the same HTML head and body earlier ... -->
<script>
  // Elements (assumes same element IDs as your provided HTML)
  const sourceInput = document.getElementById('sourceInput');
  const intervalInput = document.getElementById('intervalInput');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const reloadNowBtn = document.getElementById('reloadNowBtn');
  const sendBtn = document.getElementById('sendBtn');
  const uploadImageBtn = document.getElementById('uploadImageBtn');
  const status = document.getElementById('status');
  const pollInfo = document.getElementById('pollInfo');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const canvasInfo = document.getElementById('canvasInfo');

  // Defaults: set source to server static plot
  if (!sourceInput.value) sourceInput.value = '/static/plot.png';

  let pollTimer = null;
  let lastFetchTime = null;
  let fetchCount = 0;

  function setStatus(msg, isError){ status.textContent = msg || ''; status.style.color = isError ? 'crimson' : ''; }
  function setPollInfo(msg){ pollInfo.textContent = msg; }

  function drawPlaceholder(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#222';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#888';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No image loaded — set source and press Start', canvas.width/2, canvas.height/2);
  }
  drawPlaceholder();

  function drawImageObject(img){
    const maxW = 800;
    const maxH = 800;
    let w = img.width;
    let h = img.height;
    const ratio = Math.min(maxW / w, maxH / h, 1);
    w = Math.round(w * ratio);
    h = Math.round(h * ratio);
    canvas.width = w;
    canvas.height = h;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    canvasInfo.textContent = `Canvas: ${w} × ${h}`;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  }

  // Fetch image (single attempt). Append cache-busting timestamp to avoid browser caching.
  async function fetchAndDraw(url){
    if(!url) { setPollInfo('No source set.'); return; }
    setStatus('');
    setPollInfo('Fetching...');
    try{
      // add cache-busting param
      const sep = url.includes('?') ? '&' : '?';
      const fetchUrl = url + sep + 'ts=' + Date.now();
      const res = await fetch(fetchUrl, { method: 'GET', cache: 'no-store' });
      if(!res.ok){ setPollInfo(`GET failed: ${res.status} ${res.statusText}`); return; }
      const blob = await res.blob();
      if(!blob.type.startsWith('image/')){ setPollInfo('Fetched resource is not an image.'); return; }
      const img = new Image();
      img.onload = ()=>{ URL.revokeObjectURL(img.src); drawImageObject(img); lastFetchTime = new Date(); fetchCount++; setPollInfo(`Last: ${lastFetchTime.toLocaleString()} — fetches: ${fetchCount}`); };
      img.onerror = ()=>{ setPollInfo('Failed to decode fetched image.'); };
      img.src = URL.createObjectURL(blob);
    }catch(err){
      setPollInfo('Network/CORS error: ' + err.message);
    }
  }

  function startPolling(){
    const src = sourceInput.value.trim() || '/static/plot.png';
    const intervalSec = Number(intervalInput.value) || 30;
    if(!src){ setPollInfo('Please set an image source before starting.'); return; }
    // Disable source control after start — one-time set
    sourceInput.disabled = true;
    intervalInput.disabled = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    reloadNowBtn.disabled = false;
    // immediate fetch
    fetchCount = 0;
    fetchAndDraw(src);
    // set interval
    pollTimer = setInterval(()=> fetchAndDraw(src), Math.max(1, intervalSec) * 1000);
    setPollInfo('Polling started — fetching now...');
  }

  function stopPolling(){
    if(pollTimer) clearInterval(pollTimer);
    pollTimer = null;
    sourceInput.disabled = false;
    intervalInput.disabled = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    reloadNowBtn.disabled = false;
    setPollInfo(`Polling stopped — last fetch: ${lastFetchTime ? lastFetchTime.toLocaleString() : 'never'} (count: ${fetchCount})`);
  }

  startBtn.addEventListener('click', ()=>{ startPolling(); });
  stopBtn.addEventListener('click', ()=>{ stopPolling(); });
  reloadNowBtn.addEventListener('click', ()=>{
    const src = sourceInput.value.trim() || '/static/plot.png';
    if(!src){ setPollInfo('No source set.'); return; }
    fetchAndDraw(src);
  });

  // Send interval to backend and also update local polling if running
  sendBtn.addEventListener('click', async ()=>{
    const val = Number(intervalInput.value);
    if(!Number.isFinite(val) || val <= 0){ setStatus('Interval must be a positive number', true); return; }
    sendBtn.disabled = true;
    setStatus('Sending interval to backend...');
    try{
      const res = await fetch('/api/settings', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({interval_seconds: val})
      });
      if(!res.ok){ const txt = await res.text(); setStatus(`Server error: ${res.status} ${txt}`, true); }
      else {
        const data = await res.json().catch(()=>null);
        setStatus('Interval updated on server.' + (data ? ' Response: ' + JSON.stringify(data) : ''));
        // If polling is active, restart the local interval to match new value
        if(pollTimer){
          const src = sourceInput.value.trim() || '/static/plot.png';
          clearInterval(pollTimer);
          pollTimer = setInterval(()=> fetchAndDraw(src), Math.max(1, val) * 1000);
          setPollInfo(`Polling (client) restarted with ${val}s interval.`);
        }
      }
    }catch(err){ setStatus('Network error: ' + err.message, true); }
    finally{ sendBtn.disabled = false; }
  });

  // Upload canvas as PNG to backend (keeps your existing handler /api/upload-image)
  uploadImageBtn.addEventListener('click', async ()=>{
    setStatus('Preparing image...');
    canvas.toBlob(async (blob) =>{
      if(!blob){ setStatus('Failed to create image blob.', true); return; }
      setStatus('Uploading image...');
      const form = new FormData();
      form.append('image', blob, 'canvas.png');
      try{
        const res = await fetch('/api/upload-image', { method: 'POST', body: form });
        if(!res.ok){ const txt = await res.text(); setStatus(`Upload failed: ${res.status} ${txt}`, true); }
        else { const data = await res.json().catch(()=>null); setStatus('Image uploaded successfully.' + (data ? ' Response: ' + JSON.stringify(data) : '')); }
      }catch(err){ setStatus('Network error: ' + err.message, true); }
    }, 'image/png');
  });

  // Auto-fill source from query param (but still one-time)
  (function autoFillFromQuery(){
    try{
      const params = new URLSearchParams(location.search);
      const imageParam = params.get('image');
      const intervalParam = params.get('interval');
      if(imageParam) sourceInput.value = imageParam;
      if(intervalParam && Number(intervalParam) > 0) intervalInput.value = Number(intervalParam);
    }catch(e){ /* ignore */ }
  })();

  // Clean up on unload
  window.addEventListener('beforeunload', ()=>{ if(pollTimer) clearInterval(pollTimer); });

  // Optionally, load the server's current interval on page load and fill field
  (async function loadServerInterval(){
    try{
      const res = await fetch('/api/settings');
      if(res.ok){
        const data = await res.json();
        if(data && data.interval_seconds) intervalInput.value = data.interval_seconds;
      }
    }catch(e){}
  })();

</script>

